---
title: "General Assignment 2"
subtitle: ""
author: "Rcourse2023 Team"
date: "February 9th, 2023"
output:
  html_document:
    highlight: tango
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: 2
    df_print: default
    code_folding: show
    toc_float: TRUE
    self_contained: true
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
  h1{ font-size: 16pt; }
  h2{ font-size: 16pt; }
  h3{ font-size: 15pt; }
  h4{ font-size: 15pt; }
  h5{ font-size: 12pt; }
  h6{ font-size: 12pt; }
  body{ font-size: 14pt; }
  .credits{ 
    color: blue;
    font-size: 18pt; 
    font-weight: bold;
  }
  .tasks{
    color: blue;
    font-size: 14pt; 
    font-weight: bold;
  } 
  .emphasized{ 
    color: red;
    font-size:1em;
    font-weight: bold;
  }
</style>
  
```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE, 
                      collapse = F, 
                      tidy=TRUE, 
                      warning = F,
                      message=F,
                      fig.align = 'center', 
                      fig.height=7, 
                      fig.width=7)
```
***

# Initial Notes {-}

This is the second General Assignment of the Rcouse 2023. 

You are required to submit this assignment to get a final grade. Remember
The final grade is calculated numerically: 20% weekly assignments (top 10 grades), 40% General assignment 1 and 40 General assignment 2.

**Common instructions:**

* Add your name (Latin characters only) at the beginning of this document
for **author**, but don't modify the rest of the upper part of the document 
so that the html document renders appropriately.
* Use the given spaces to write your code, don't change the order of chunks of
code, and avoid editing the instructions.
* Answer the questions given throughout the assignment at the **very bottom** 
section of the document.
* When you are finished and ready to submit, use the **knitr** button
above the Rstudio IDE to render (create) the html document to check that it is
done correctly.
* IMPORTANT: Omit or comment lines that INSTALL packages and that PRINT 
unnecessary information like entire tables of data. Do not include local
file PATHS.
* **Save** your results in a specific named variable when instructed. Failing to do so will result in penalties.
* You have until midnight of the deadline day to submit your answers.

Good luck!

---

# Setup {-}

## Install and load the following required packages {-}

* From CRAN:
  + pheatmap
  + ggplot
  + magrittr
  + dplyr
 
* From Bioconductor:
  - tximport
  - DESeq2
  - LSD
  - SummarizedExperiment


> You may have to install some of these packages first. <br />
Do not include installation commands in your submitted answer (at the very
least comment them using '#' at the start of line) <br/>
A penalty will be applied if you ignore this. <br />

***Please, report any problems with package installation ASAP!***

```{r message=FALSE, include=FALSE}
#---Install packages from CRAN---
library(ggplot2)
library(magrittr)
library(pheatmap)
library(dplyr)

#---Install packages from Bioconductor---
library(SummarizedExperiment)
# if LSD is not installed, install it
library(DESeq2)
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
    BiocManager::install("LSD")
    BiocManager::install("tximport")
library(LSD)
library(tximport)
#--done--
```




# TASK1: DESeq analysis of APEX-tagged genes

In this assignment, you will analyze RNA-seq data from a recent 
[paper](https://elifesciences.org/articles/29224). In this work, the authors 
developed a method termed APEX-RIP, which maps transcriptomes to sub cellular 
compartments based on proximity to a specific protein. 

The four proteins used in this study are markers from different cellular locations:

  1) A mitochondrial protein (Mito), 
  2) An ER membrane protein (KDEL-HRP),
  3) A nuclear localization sequence (NLS),
  4) A nuclear export sequence (NES).

For each of these fusions, RNAs labelled with biotin ("RIP") were compared 
to a non-labelled background ("Input"), each with 2-3 replicates. The RNA-seq 
data were quantified using RSEM and gene annotations taken from RefSeq.
The file "rsem_files_ex.txt" consists in a table, *a.k.a* Design Matrix, assigning
each file within the zipped archive has a specific condition and replicate number.

***Notes:***

* RSEM is an accurate and user-friendly software tool for quantifying transcript
abundances from RNA-Seq data. RSEM implements an algorithm to assign reads to 
the isoforms from which they are more likely to be originated.
* Therefore the transcript level is not to be mistaken for read counts. 
It is a quantitative estimation of transcript abundance given RNA-seq data.

## Load RSEM data

### Read the table "rsem_files_ex.txt" into an object called `ftab`. 

This file catalogues RNA-seq experiments in the form of a table with 3 columns: <br />
 (i) The RSEM output file <br />
 (ii) Condition tested for each experiment <br />
 (iii) The number of the replicate <br />

### Load RSEM files

Load all the RSEM files into a variable called `rse` using tximport() and the `ftab`object.

***Note:***

> To prevent reloading data if you made a mistake, we suggest creating a backup
copy of the `rse` to an object called `rse.bak`. If somehow you altered the data, 
you can restore the original data from the backup running the following command:
`rse <- rse.bak` <br />
> Alternatively, you could `save()` the object `rse` to an RData file. Then read
the file with the function `load()` whenever you need to restore data. <br />

### Filter out transcripts that their **minimum** length is **shorter** than 300 bases

You can make a logical vector to indicate which rows correspond to transcripts with a minimum
'length' value **greater or equal** to 300 in the corresponding matrix. Then
subset the ***counts***, ***abundance*** and ***length*** data in `rse` (`rse` is a list that includes 3 data sets) with this logical vector.


```{r echo=TRUE, warning=FALSE, "1a-load-data", message=F}
#--------------------------Starting with reading the tbl-------------------------------
ftab <- read.table("rsem_files_ex.txt")
#--------------------------adding the headers to the table--------------------------------
#colnames(ftab) <- c("files", "condition", "replicate", "replicate_number")
#--------------------------load the RSEM files------------------------------------------
rse <- tximport(ftab$V1, type="rsem")
# rse <- tximport(files = ftab$files, type = "rsem")
#--------------------------Backup the original data--------------------------------------
rse.bak <- rse
#--------------------------save the original data----------------------------------------
save(rse, file = "rse.bak.RData")
#---Done with the first part---
#--------------------------Filter out transcripts that their minimum length is shorter than 300 bases--------------------------------
#----creating a logical vector to indicate which rows in the 
# rse$length is true for length >= 300
valLength <- apply(rse$length, 1, min) >= 300
#----subset the counts, abundance and length data in rse
rse$counts <- rse$counts[valLength, ]
rse$abundance <- rse$abundance[valLength, ]
rse$length <- rse$length[valLength, ]
#---Done with the second part---
# ðŸ˜Š
```

## Compare biotin-labeled *vs.* all RNAs across four experiments using DESEQ2

### Make a data frame with information about the design of all experiments

Using `ftab`, create a data frame `cdat` with 2 columns of factors:
 1) condition
 2) replicate (with their respective number)

### Make a DESeqDataSet using the design data frame

*Hint: use the object constructor `DESeqDataSetFromTximport()` with the design*
*formula `~condition+replicate` based on `cdat` and `rse`*  

**Save** the DESeqDataSet object inside `ds.txi`

*Q1- How many genes do you have in the dataset?*  
**Save** your answer in a variable `ANSWER1`

### Run the DESeq analysis (*i.e.* differential expression analysis)

*Hint: use `DESeq()` function on the DEseqDataSet object.*
***Important! make sure to set the parameter `betaPrior=TRUE`.***

### **Save** the DESeqDataSet object inside `ds`

### Filter results for low counts genes.

Make sure to only keep rows for which the sum of counts per row is **greater than 10**.
Use the function `counts()` to access count values from a DESeq results object.
**Save** the filtered results in an object called `dds`.

*Q2- What fraction (in %) of genes were removed?* <br/>

**Save** your answer in a variable `ANSWER2`

*Q3- What fraction (in %) of genes were retained?* 

**Save** your answer in a variable `ANSWER3`
```{r echo=TRUE, "1b-DESEQ2", include=FALSE}
#----- starting with the first part of the task-----
#-----adding the replicate number to the replicate name in the ftab table-----
# ftab$replicate <- paste0(ftab$replicate, ftab$replicate_number)

#-----creating a design data frame with the condition and replicate columns as factors-----
cdat = data.frame(
  condition = as.factor(paste0(ftab$V2, '-', ftab$V3)), 
  replicate = as.factor(ftab$V4)
  )
#set the levels of the condition column
replicate = factor(ftab$V3)

#### Make a DESeqDataSet using the design data frame
ds.txi = DESeqDataSetFromTximport(txi = rse ,colData = cdat, design = ~condition+replicate)
saveRDS(ds.txi, file = "ds.txi.rds")

ANSWER1 = nrow(ds.txi)

# ----- starting with the second part of the task-----
# Run the DESeq analysis (i.e. differential expression analysis)
ds <- DESeq(ds.txi, betaPrior=TRUE)

# Filter results for low counts genes
genes_to_keep<-apply(counts(ds),1,function(x) sum(x)>10)

dds<-ds[genes_to_keep,]

# Calculate the fraction of genes removed
ANSWER2 = round((1 - nrow(dds)/nrow(ds.txi)) * 100, 2)

ANSWER3 = round((nrow(dds)/nrow(ds.txi)) * 100, 2)
# ðŸ˜Š
#-----Done with the second part of the task-----
# ---Done-----
```

## Enrichment of differentially expressed genes per compartment

### Find the number of significantly enriched genes in each compartment

***Significantly enriched genes*** should have passed the statistical test on their
fold-change expression between conditions (*based on averaged across replicates*)
and yielded an *adjusted p-value* below the arbitrary threshold of 0.05.

*The null hypothesis of the test is that the effect of the condition does not 
affect expression. Hence the fold-change of expression remains at 1 
(or 0 on a log scale)*

To access results from a DESeq analysis, use the `results()` function.
Make sure to set the threshold for `alpha` to 0.05, specify in the contrast
argument what should be compared (conditions or replicates) followed by the names
of the conditions/replicates as specified in `cdat`. 
*Hint: check the help of results for examples*

Extract the results of differential RNA expression for each compartment 
(Mito, ER, NLS, NES) between biotin-labelled (referred as 'RIP') *vs.* their 
respective background (referred to as 'Input').<br>

**Print the summary of each result objects to the console.**

```{r 1c-enrichment, echo=TRUE}
res_Mito <- results(dds, 
                    contrast = c("condition", "Mito-APEX2 RIP", "Mito-APEX2 Input"),
                    alpha = 0.05)

res_ER <- results(dds, 
                  contrast = c("condition", "KDEL-HRP RIP", "KDEL-HRP Input"),
                  alpha = 0.05)

res_NLS <- results(dds, 
                    contrast = c("condition", "NLS-APEX2 RIP", "NLS-APEX2 Input"),
                    alpha = 0.05)

res_NES <- results(dds, 
                    contrast = c("condition", "NES-APEX2 RIP", "NES-APEX2 Input"),
                    alpha = 0.05)

all_res=c(res_ER,res_Mito,res_NES,res_NLS)
names(all_res)=c('ER','Mito','NES','NLS')

#---Print the summary of each result objects to the console
print(summary(res_Mito))
print(summary(res_ER))
print(summary(res_NLS))
print(summary(res_NES))
#---Done---
# ðŸ˜Š
```

### Barplot: Strong DE genes

Make a barplot with the number of strong differentially expressed genes for each condition.

For each condition, make a logical vector to identify significantly regulated genes 
within the result object with an adjusted p-value below 0.05 AND **absolute** 
log2fold-change greater than 1. 
*You can use the `$` operator to extract data from the result object from the previous step.*

1) Calculate the total number of significantly regulated genes in each compartment.
2) Store those numbers in a vector and use the vector for generating the barplot.
3) Each bar should correspond to one condition; its height would represent the
number of genes significantly regulated.
4) Indicate in the title the value for each bar: Mito:__ ER:__ NLS:__ NES:__

**You are asked to extract the number of genes with R commands so do not just write the number**


```{r echo=TRUE}
#sum and store the number of strong DE genes if not NA
strong_mito <- res_Mito$padj < 0.05 & abs(res_Mito$log2FoldChange) > 1
strong_er <- res_ER$padj < 0.05 & abs(res_ER$log2FoldChange) > 1
strong_nls <- res_NLS$padj < 0.05 & abs(res_NLS$log2FoldChange) > 1
strong_nes <- res_NES$padj < 0.05 & abs(res_NES$log2FoldChange) > 1

#df for the barplot
significant_genes <- c(sum(strong_mito, na.rm = T), sum(strong_er, na.rm = T),
    sum(strong_nls, na.rm = T), sum(strong_nes, na.rm = T))
names(significant_genes) <- c("Mito", "ER", "NLS", "NES")

# plotting:
barplot(significant_genes, main = paste0("Mito:", significant_genes[1], "   ER:",
    significant_genes[2], "   NLS:", significant_genes[3], "   NES:", significant_genes[4]),
    xlab = "Compartment", ylab = "Number of Significantly Regulated Genes")
#---Done---
# ðŸ˜Š
```

\newpage

## log2fold-change NLS *vs.* NES heat-scatterplot

Next, we want to evaluate the correlation for expression between different conditions.
(*e.g.* NLS *vs.* NES).

Scatterplots are often misinterpreted whenever the density is not taken into account.
The `heatscatter()` function from the `LSD` package solves this issue by
estimating the points' density and showing it as a color gradient. 

### HeatScatter plot

Use the log2FoldChange from the result object of both compartments (NLS *vs* NES)
within the heatscatter() function. **Make sure to display** the correlation 
coefficient as the title using the correct parameter of the `heatscatter()` 
function, ***cor = TRUE***.

*Q4- What are the Pearson and Spearman correlation coefficients between the log2-fold*
*changes in NLS and NES experiments?* <br />
> Hint: You can use the `cor()` function to calculate the r coefficient using both the "Spearman" and "Pearson" method  
**Save** your answer in a variable `ANSWER4` 

```{r heatscatter, echo=TRUE}
#---HeatScatter plot
heatscatter(res_NLS$log2FoldChange, res_NES$log2FoldChange, cor = TRUE)
#---Calculate the Pearson and Spearman correlation coefficients
cor.pearson <- cor(res_NLS$log2FoldChange, res_NES$log2FoldChange, method = "pearson")
cor.spearman <- cor(res_NLS$log2FoldChange, res_NES$log2FoldChange, method = "spearman")

#--- make the answer
ANSWER4 = paste("Pearson:", round(cor.pearson, 4), "Spearman:", round(cor.spearman, 4))
```

\newpage

## Similarity and hierarchical clustering on log-transformed data

### log-space counts

Use `rlog()` to transform the DESEQdataset counts into log space and **save** it in a new
object called `rld`. 
*Hint: use `rlog()` function without prior information on samples.*
*Check the function's help for more info.*

### Summarized Experiment

Convert the log-transformed data `rld` to an object called `SE` of class 
'summarizedExperiment' *Hint: use the function `assay()`*

### Euclidean distance between genes

Compute the euclidean distance between differentially expressed genes. 

*Hint: use `dist()` to calculate the euclidean distance between samples in the *
*summarized experiment results in `SE`.* *You may need to transpose the data, **
**as dist() calculates the distance between rows of the input data* <br>

**Save** inside `dsample`, the variable `SE` as a dist object  
**Save** inside `m.dsample` the variable `dsample` as a matrix object

### Heatmap: Sample similarity

Create a heatmap of distances between samples: **Distance values should be**
**represented with a color gradient.** *For example, darker shades can reflect 
larger distances between observations, and lighter shades for observations with 
short distances.* 

Set the arguments, cellwidth = 10 and display_numbers = T

*Hint: use `pheatmap()` function with the calculated euclidean distance for 
both rows and columns clustering calculation*

***Notes:***

> You must convert the distance object to a matrix for `pheatmap()`. <br />
Set: <br>

* rownames to reflect the various conditions and replicates.  
* clustering_distance_rows = dsample,  
* clustering_distance_cols = dsample,
* cellwidth = 10,
* show_colnames = F,
* show_rownames = F,
* fontsize = 5,
* main = "Sample similarity as Euclidean distance", 
* display_numbers = T


This information is accessible in the `rld` object or from the initial `cdat` 
design data frame from the previous step. 
*Q5- Based on the heatmap, which sample group is the most distanced from the rest of the treatments?*  
**Save** your answer in a variable `ANSWER5` (10 words maximum)

```{r 1d-sim.mat-hclust, echo=TRUE, cache=FALSE}
#---log-space counts
rld <- rlog(dds)
#---Summarized Experiment
SE <- assay(rld)
#---Euclidean distance between genes
dsample <- dist(t(SE))
m.dsample <- as.matrix(dsample)

#renames the number of rows in the distance matrix to the condition and replicate
rownames(m.dsample) <- paste0(cdat$condition, cdat$replicate)
#----heatmap
pheatmap(m.dsample, 
         rownames = paste0(cdat$condition, cdat$replicate),
         clustering_distance_rows = dsample,
         clustering_distance_cols = dsample,
         cellwidth = 10,
         show_colnames = F,
         show_rownames = T,
         fontsize = 5,
         main = "Sample similarity as Euclidean distance", 
         display_numbers = T) 


ANSWER5 = "the most distanced treatments is KDEL-HRP"
len.ANSWER5 = print(length(unlist(strsplit(ANSWER5,split = " ")))) # DON'T delete!

```

---

# Task3: Data quailty and multiple testing  

## Load the data

* Load single cell data "caron_mat.RDS" and save it inside a variable `data_sc`.   
* Load the meta data "caron_metadata.RDS" and save it inside a variable `metadata_sc`
 

> Important: Single cell data include information about the expression of genes within multiple cells. **Take** a moment and understand what the rows and columns of `data_sc` represent  

```{r read_data, echo=TRUE}
data_sc <- readRDS("caron_mat.RDS") 
metadata_sc <- readRDS("caron_metadata.RDS")
```

***Q6***: The values in `data_sc` are TPM (transcripts per million)/scaled (Centred Values are: Xi-mean(x))/centered (z-score values i.e. (Xi-mean(x))/sd(x) just like we have learned in the lesson about PCA)?<br> 
Explore the data in the following chunk:</br> 

1)  Print/Plot maximum 3 plots  
2)  **Don't** print text/number/vector/data set information.</br>

***Explain*** you answer (30 words **maximum**) and **save**  it in a variable `ANSWER6`. 

```{r q1, echo=TRUE}
#reshape the data to long format
library(tidyr)
library(reshape)
library(tibble)
dat.long <- data_sc %>% as.data.frame() %>% rownames_to_column(var = "genes") %>% 
  gather(key = "samples", value = "TPM", -genes)
#add to dat.long the metadata base on the sample column match to cell_name in the metadata_sc
dat.long <- left_join(dat.long, metadata_sc, by = c("samples" = "cell_name"))

#drop all na values
dat.long <- dat.long[!is.na(dat.long$cell_type),]

#---EDA
#store the most 25 expressed genes in a variable
top25 <- dat.long %>% group_by(genes) %>% summarise(mean_TPM = mean(TPM)) %>% top_n(25, mean_TPM) %>% pull(genes)

   
# barplot of the most 25 expressed genes
dfToPlot<- dat.long %>% filter(genes %in% top25) 
ggplot(dfToPlot, aes(x = genes, y = TPM ,fill = cell_type)) +
geom_bar(stat = "identity") +
coord_flip() 

#boxplot of the most 5 expressed genes
#df of dat.long with od the most 5 expressed genes
dfToPlot<- dat.long %>% filter(genes %in% top25[1:5])
ggplot(dfToPlot, aes(x = genes, y = TPM ,fill = cell_type)) +
geom_boxplot() +
coord_flip()

# density plot of the most 50 expressed genes
top50 <- dat.long %>% group_by(genes) %>% summarise(mean_TPM = mean(TPM)) %>% top_n(50, mean_TPM) %>% pull(genes)
dfToPlot<- dat.long %>% filter(genes %in% top50[1:50])
ggplot(dfToPlot, aes(x = TPM, fill = cell_type)) +
geom_density(alpha = 0.3) + 
xlim(0, 15000)


ANSWER6 = "I chose to plot the most expressed genes in thedatato understand the distribution of the data. The plots show the distribution of the data in the most expressed genes."
len.ANSWER6 = print(length(unlist(strsplit(ANSWER6,split = " ")))) # DON'T delete!
#---Done---
# ðŸ˜Š
```

## Log transform the data<br>

1) Log transform the data. First, divide by 10 each value in the data, add 1 to handle zero values and finally, log2 transform.   
2) If the data is not centered, center it by deducting the mean of each row from each value in that row.  
3) **Save** the log transform data and centered data in a variable `cent_mat`

```{r log_center, echo=TRUE}
log_data <- log2((data_sc/10) + 1)
cent_mat <- scale(log_data, center = TRUE, scale = FALSE)
```

## QC The data<br>

Calculate the complexity of each cell in the `log_data` (Apply the same calculation from weekly Ex.9).<br>

1) Keep cells with complexity larger than 500 and store the results in a variable `comp_up`

```{r comp, echo=TRUE}
#---Calculate the complexity of each cell in the log_data
comp_up <- apply(log_data, 2, function(x) sum(x > 0))
#getting logical vector of cells with complexity larger than 500
comp_up <- comp_up > 500
```

2) Filter `cent_mat` according to `comp_up`, keep cells with high complexity and **save** the filtered data set in `cent_filt`

3) Filter `metadata_sc` according to `comp_up`, keep cells with high complexity and **save** the filtered data set in `metadata_sc_filt`

3) Filter `log_data` according to `comp_up`, keep cells with high complexity and **save** the filtered data set in `log_data_filt`

```{r filter_cells, echo=TRUE}
cent_filt <- cent_mat[, comp_up]
metadata_sc_filt <- metadata_sc[comp_up, ]
log_data_filt <- log_data[, comp_up]
# print the amouut of cell subsetting and the amouunt of cell removed
# print(paste("The number of cells with high complexity is:", sum(comp_up)))
# print(paste("The number of cells with low complexity is:", sum(!comp_up)))
```
## Finding the highly expressed genes
Using `log_data` (unfiltered by complexity) find the top 7000 genes with the highest **mean** expression.  

**Save** in a variable `cent_final` a subset of `cent_filt` with only the top 7000 most expressed genes.

```{r filter_genes, echo=TRUE}
#---Finding the highly expressed genes and logic vector of the top 7000 genes
top_genes <- apply(log_data, 1, mean)
top_genes <- order(top_genes, decreasing = T)[1:7000]

#making a subset of cent_filt with only the top 7000 most expressed genes
cent_final <- cent_filt[top_genes, ]
```

## Comparing gene expression between Malignant cell to non-Malignant cells<br>

### Cell classification  
Classified cells as Malignant cells or non-Malignant cells<br>

Add a column to `metadata_sc_filt` that is called *Malignant*.    
If the cell type indicates it's malignant, put "Malignant" in the new column and "non-Malignant" otherwise. 

```{r Malig, echo=TRUE}
malig_cells <- metadata_sc$cell_type == "Malignant"
metadata_sc_filt$Malignant <- ifelse(metadata_sc_filt$cell_type == "Malignant", "Malignant", "non-Malignant")
#drop na values in the metadata_sc_filt malig column
metadata_sc_filt <- metadata_sc_filt[!is.na(metadata_sc_filt$Malignant),]
```

### Visualisation of cell classification  
Draw a bar plot of the number of malignant cells against non malignant

```{r bar_plot, echo=TRUE}
#---Visualisation of cell classification
ggplot(metadata_sc_filt, aes(x = Malignant)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Malignant vs non-Malignant cells", x = "Cell type", y = "Number of cells")

```

## Multiple comparisons of gene expression

### Create a sample data<br>

 1) Sample out randomly (using sample()) of the malignant cells, 536 cells. 
 2) Store their names in variable `sampled_malig`
 3) Set *replace = FALSE*
 4) Store all non-Malignant cells into a variable called `non_malignant`. 
 5) Remove all NA's values from that variable. 

```{r Sample, echo=TRUE}
set.seed(2020) # Don't change!
#---Create a sample data
#get a list of 536 malignant cells names
sampled_malig <- sample(metadata_sc_filt$cell_name[metadata_sc_filt$Malignant == "Malignant"], 536, replace = FALSE)
non_malignant <- sample(metadata_sc_filt$cell_name[metadata_sc_filt$Malignant == "non-Malignant"], replace = FALSE)

#split cent_final to 2 df based on the cell names %in% sampled_malig and non_malignant
cent_final_malig <- cent_final[, sampled_malig]
cent_final_non_malig <- cent_final[, non_malignant]

```

### Multiple t.test<br>

For each gene, perform a t.test between the sampled malignant cells to the non_malignant cells using the `cent_final` matrix.  

> NOTICE! you will perform multiple test, you will need to use the HB FDR correction. <br>

1) Use the p.adjust function  to apply FDR correction to the p-values from the multiple testing before.   
2) **Save** the p-values in a variable `p_values` and the adjusted p-values store in a vector named `p_adjusted` 

```{r t_test, echo=TRUE}
# preform a t.test for each gene between cent_final_malig and cent_final_non_malig
p_values <- apply(cent_final, 1, function(x) t.test(x[sampled_malig], x[non_malignant])$p.value)

#apply FDR correction to the p-values
p_adjusted <- p.adjust(p_values, method = "fdr")

#smal plot to see the results
P <- ggplot(data = data.frame(p_values = p_values), aes(x = p_values)) +
      geom_histogram(binwidth = 0.01, fill = "steelblue",breaks = seq(0, 0.15, by = 0.025)) +
      labs(title = "Histogram of p-values", x = "p-values", y = "Frequency")+
      geom_vline(xintercept = 0.05, color = "red", linetype = "dashed")

# Create a dataframe of the values falling into each bin
df <- data.frame(p_values = p_values, p_adjusted = p_values)

#cound the number of genes with p-values < 0.05
sumofgenes <- sum(p_values < 0.05)

#print P with the df
# print(P)
# print(head(df))
#---Done---
# ðŸ˜Š

```


### Q7. Understanding the results<br>

1) load the file "pvalue_hist.rds"
2) Look at the plot in the following chunk. 
3) How would you know which histogram represents the adjusted p-values?<br>

**Save** your explaination in `ANSWER7` (maxium 30 words)
```{r echo=TRUE}
load("pvalue_hist.rds")
pvalue.hist(a = p_values,b = p_adjusted)

ANSWER7 = "the histogram with the adjusted p-values will have lower values compared to the the p-values , and 
therfore the B histogram in the blue color represents the adjusted p-values."  
len.ANSWER7 = print(length(unlist(strsplit(ANSWER7,split = " ")))) # DON'T delete!
```

---
\newpage

***

# Answer to the questions found throughout the assignment

> **Your answers should be stored in the objects `ANSWER1`, `ANSWER2`, etc. to
be printed out in the report.**

<span class='tasks'> Answers for General assignment 2 </span>

(@) **Q1** How many genes are present in the dataset? </br>
**A1** `r ANSWER1`

(@) **Q2** What number and fraction (in %) of genes with low counts were removed? </br>
**A2** `r ANSWER2`

(@) **Q3** What number and fraction (in %) of genes were retained? </br>
**A3** `r ANSWER3`

(@) **Q4** What are the Pearson and Spearman correlation coefficients between the log2-fold
changes in NLS and NES experiments? </br>
**A4** `r ANSWER4`

(@) **Q5** Based on the heatmap, which sample group is the most distanced from the rest of the treatments? (10 words maximum) </br>
**A5** `r ANSWER5` Length: `r len.ANSWER5`

(@) **Q6** The values in `data_sc` are (TPM (transcripts per million)/scaled/centered) values? explain (maximum 30 words)  </br>
**A6** `r ANSWER6` Length: `r len.ANSWER6`

(@) **Q7** How would you know histogram represents the adjusted p values? (30 words maxium) </br>
**A7** `r ANSWER7` Length: `r len.ANSWER7`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               